#命令启动springBoot项目,并指定端口
java -jar xxx.jar --server.port=8080

ehcache的适用场景： jvm缓存
    在使用过程中，根据优点和缺点进行权衡后再应用到项目中去，ehcache缓存也是如此，
    在实际工作中有很多种使用场景，在本节中还将会结合实际工作的案例，将Ehcache作为redis的二次缓存使用
 1。Ehcache场景要求
    （1）：比较少的更新数据表的情况下
 Ehcache作为Hibernate的缓存时，在进行修改表数据的时候，Ehcache会自动把缓存中关于此表的所有缓存全部删除。
 这样做只是能达到同步，但对于数据经常修改的表来说。可能失去缓存的意义了。
    （2）：对并发要求不是很严格的情况
 多台应用服务器中的缓存是不能进行实时同步的。
    （3）：对一致性要求不高的情况下
 因为Ehcache本地缓存的特征，目前无法很好的解决不同服务器间缓存同步的问题，所以在一致性要求高的场合下，建议
 使用redis、Memcached等集中式缓存。

 2。Ehcache的瓶颈点：
 Ehcache作为本地缓存能够给我们使用便利和性能提升的同时，也有一些问题所在，比如缓存漂移和数据库的瓶颈。
    （1）缓存漂移：
每个应该节点只管理自己的缓存，在更新某个节点的时候，不会影响到其他节点，这样数据直接可能就不同步了。
    （2）数据库瓶颈：
对于单实例的应用来说，缓存可以保护数据库的读风险；但是在集群的环境下，每一个应用节点都要定期保持数据更新，
节点越多，要维护这样的情况对数据库的开销越大。

3。在实际工作中如何更好的使用Ehcache
    我们使用集中式缓存（redis、Memcached等）通常都是先检查缓存中是否存在期望的数据。如果存在直接将数据返回，
如果不存在就查询数据库然后再将数据缓存，而后将结果返回。这时候如果缓存系统因为某些原因宕机，造成服务无法访问。
那么大量的请求将直接穿透到数据库，对数据库造成巨大的压力
    针对上述情况，我们有多种可行的解决方案，其中一种方案是将Ehcache作为集中式缓存的二级本地缓存，
这样当缓存系统宕机后，服务器应用的本地缓存还能继续扛住大量请求。
    使用Ehcache作为二级本地缓存后，可能会出现本地缓存与缓存系统之间出现数据不一致的情况，因为本地缓存是在服务器
应用中存在，在实际生产环境中必定有多台服务器分别部署，如何能够在更新缓存系统数据的同时，也能够更新Ehcache缓存数据，
以及怎么保证不同服务器间Ehcache本地缓存数据的同步问题，下面将提供两种解决方案。
    （1）方案一：定时轮询
每台应用服务器定时轮询Redis缓存，比较缓存数据的版本号与本地Ehcache缓存的版本号大小。如果本地Ehcache缓存的版本号小于
Redis缓存的版本号，则可以获取的最新的缓存，然后同步更新本地Ehcache缓存。
    缺点：因为每台服务器定时轮询的时间点可能不一样，那么不同服务器刷新最新缓存的时间可能也不一样，这样就会产生数据不一致
        的问题，对一致性要求不是很高的时候可以使用
    （2）方案二：主动通知
这种方式引入了消息队列，使每台应用服务器的ehcache同步侦听MQ消息，通过MQ推送或者拉取的方式，这样在一定程度上可以达到准同步更新数据
    缺点：因为不同服务器之间的网络速度的原因，所以也不能完全达到强一致性。基于此原理使用zookeeper等分布式协调通知组件也是如此

总结：总之使用二级缓存的好处是减少缓存数据的网络传输开销，当集中式缓存出现故障的时候，Ehcache等本地缓存依然能够支撑应用程序正常使用，
增加了程序的健壮性。另外使用二级缓存策略可以在一定程度上阻止缓存穿透问题。如果要使用强一致性缓存，集中式缓存是最佳选择，redis,memcached等。

Guava Cache的使用：jvm缓存
    1。Guava Cache的适用场景
    （1）愿意消耗一些本地内存空间来提升速度
一些数据对一致性要求不高，就可以不用放到Redis等集中缓存中，这样频繁读取还会增加网络开销，同时也需要考虑集中缓存宕机情况。
我们在使用本地内存做缓存的时候，也需要考虑缓存的数据总量不能超过服务器内存，这样就应该做一些数据淘汰机制来确保。
    （2）更新锁定
这个功能很好用，当请求查询某一个key的时候，如果不存在则从源中读取，然后再回填到本地缓存中，这时如果并发量非常大，
可能会有多个请求同时从源中读取数据，然后再回填到本地缓存。造成多次执行的情况。
Guava Cache 可以在CacheLoader的load方法中加以控制，对同一个key，只让一个请求去源中读取数据，而其他请求阻塞等待结果。
   2。Guava Cache的创建方式：忽略
   3。缓存数据删除：数据删除的方式有两种，分别是主动删除和被动删除。
    （1）。被动删除
        基于数据大小的删除：按照缓存的大小来删除，如果缓存容量即将到达指定的大小时，就会把不常用的键值对从cache中移除。
        基于过期时间删除：
        基于引用的删除：这种方式主要是基于java的垃圾回收机制，判断缓存的数据引用的关系，如果没有被引用，则数据被移除




































